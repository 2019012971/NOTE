# 计时器
```js
//测试如下的程序的性能
    //在程序执行前，开启计时器
    //console.time("计时器的名字")可以用来开启一个计时器
    //它需要一个字符串作为参数，这个字符串将会作为计时器的标识
    console.time("test");
    
    //打印2-100之间所有的数
    for(var i=2 ; i<=100000 ; i++){
        var flag = true;
        for(var j=2 ; j<=Math.sqrt(i) ; j++){
            if(i%j == 0){
                //如果进入判断则证明i不是质数,修改flag值为false
                flag = false;
                //一旦进入判断，则证明i不可能是质数了，此时循环再执行已经没有任何意义了
                //使用break来结束循环
                break;
                
                //不加break 215ms
                //加break 25ms
                //修改j<=后 2.6
            }
        }
        //如果是质数，则打印i的值
        if(flag){
            //console.log(i);
        }
    }
    
    //终止计时器
    //console.timeEnd()用来停止一个计时器，需要一个计时器的名字作为参数
    console.timeEnd("test");
```
# 使用unicode编码
```html
<!--在网页中使用Unicode编码-->
    <!--&#编码; 这里的编码需要的是10进制-->
    <h1 style="font-size: 200px;">&#9760;</h1>
    <h1 style="font-size: 200px;">&#9856;</h1>
```
# 对象（Object）
```js
	- 对象是JS中的引用数据类型
	- 对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性
	- 使用typeof检查一个对象时，会返回object
	- 创建对象
		- 方式一：
			- var obj = new Object();
		- 方式二：
			- var obj = {};
			
	- 向对象中添加属性
		- 语法：
			对象.属性名 = 属性值;
			对象["属性名"] = 属性值;
			
			- 对象的属性名没有任何要求，不需要遵守标识符的规范，
				但是在开发中，尽量按照标识符的要求去写。
			- 属性值也可以任意的数据类型。

	- 读取对象中的属性
		- 语法：
			对象.属性名
			对象["属性名"]
		- 如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined
		
	- 删除对象中的属性
		- 语法：
			delete 对象.属性名
			delete 对象["属性名"]
			
	- 使用in检查对象中是否含有指定属性
		- 语法："属性名" in 对象
			- 如果在对象中含有该属性，则返回true
				如果没有则返回false
				
	- 使用对象字面量，在创建对象时直接向对象中添加属性
		语法：
			var obj = {
				属性名:属性值,
				属性名:属性值,
				属性名:属性值,
				属性名:属性值
				};
					
	- 基本数据类型和引用数据类型
		- 基本数据类型
			String Number Boolean Null Undefined
		- 引用数据类型
			Object
		- 基本数据类型的数据，变量是直接保存的它的值。
			变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。
		- 引用数据类型的数据，变量是保存的对象的引用（内存地址）。
			如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。
		- 比较两个变量时，对于基本数据类型，比较的就是值，
			对于引用数据类型比较的是地址，地址相同才相同
```

# 函数（Function）	
	- 函数也是一个对象，也具有普通对象的功能
	- 函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码
	- 使用typeof检查一个函数时会返回"function"
	- 创建函数
		- 函数声明
			function 函数名([形参1,形参2...形参N]){
				语句...
			}
		
		- 函数表达式
			var 函数名 = function([形参1,形参2...形参N]){
				语句...
			};
			
	- 调用函数
		- 语法：函数对象([实参1,实参2...实参N]);
			fun() sum() alert() Number() parseInt()
		- 当我们调用函数时，函数中封装的代码会按照编写的顺序执行

	- 形参和实参
		- 形参：形式参数
			- 定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开
				定义形参就相当于在函数内声明了对应的变量但是并不赋值，
				形参会在调用时才赋值。
				
		- 实参：实际参数
			- 调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参,
				调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。
				如果实参的数量大于形参，多余实参将不会赋值，
				如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined
**- 例子：**
```js
    function sum(a,b) {
                console.log(a+b);
    }
    sum(1,2);
```

# 函数(续)
```js
	- 返回值，就是函数执行的结果。
		- 使用return 来设置函数的返回值。
		- 语法：return 值;
			- 该值就会成为函数的返回值，可以通过一个变量来接收返回值
		- return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出。
		- return后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。
		- 如果return后不跟值，或者是不写return则函数*默认*返回undefined。
		- break、continue和return
			- break
				- 退出循环
			- continue
				- 跳过当次循环
			- return
				- 退出函数
				
	- 参数，函数的实参也可以是任意的数据类型。
		- area() 调用函数，相当于使用函数的返回值；
		- area   函数对象，相当于直接使用函数对象；
	
	- 立即执行函数：(function () {
            		    alert("hhh");
        		})();

	- 方法（method）
		- 可以将一个函数设置为一个对象的属性，
			当一个对象的属性是一个函数时，
				我们称这个函数是该对象的方法。
		- 对象.方法名();
		- 函数名();	
```
## 枚举"对象"里面的属性（for in 循环）
```js
for (const objKey in document) {
            console.log(objKey+":"+document[objKey]);
}
```
2.作用域
	- 作用域简单来说就是一个变量的作用范围。
	- 在JS中作用域分成两种：
		1.全局作用域
			- 直接在script标签中编写的代码都运行在全局作用域中
			- 全局作用域在打开页面时创建，在页面关闭时销毁。
			- 全局作用域中有一个全局对象window，window对象由浏览器提供，
				可以在页面中直接使用，它代表的是整个的浏览器的窗口。
			- 在全局作用域中创建的变量都会作为*window对象*的属性保存 var a = 10; 相当于window.a ===10;
				在全局作用域中创建的函数都会作为window对象的方法保存
			- 在全局作用域中创建的变量和函数可以在页面的任意位置访问。
				在函数作用域中也可以访问到全局作用域的变量。
			- 尽量不要在全局中创建变量	
			
		2.函数作用域
			- 函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。
			- 函数作用域在函数执行时创建，在函数执行结束时销毁。
			- 在函数作用域中创建的变量，不能在全局中访问。
			- 当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，
				如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，
					如果找到了则使用，找不到则继续向上找，一直会
					
		- 变量的声明提前
			- 在全局作用域中，使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值。
				所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前。
			- 在函数作用域中，也具有该特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，
				如果没有使用var关键字声明变量，则变量会变成全局变量
				
		- 函数的声明提前
			- 在全局作用域中，使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建，
				也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性
			- 在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。
		-总而言之：（var a = 10；）和（function fun(){}；）会在所有的代码执行之前被创建（var a；//此时不会对a赋值）

3.this（上下文对象）	
	- 我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。
		使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。
	- this的不同的情况：
		1.以函数的形式调用时，this是window
		2.以方法的形式调用时，this就是调用方法的对象
		3.以构造函数的形式调用时，this就是新创建的对象
		
4.构造函数
	- 构造函数是专门用来创建对象的函数
	- 一个构造函数我们也可以称为一个类
	- 通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例
	- 通过同一个构造函数创建的对象，我们称为一类对象
	- 构造函数就是一个普通的函数，只是他的调用方式不同，
		如果直接调用，它就是一个普通函数
		如果使用new来调用，则它就是一个构造函数
		
	- 例子：
		function Person(){
		
		}
		
	- 构造函数的执行流程：
		1.创建一个新的对象
		2.将新的对象作为函数的上下文对象（this）
		3.执行函数中的代码
		4.将新建的对象返回
		
	- instanceof 用来检查一个对象是否是一个类的实例
		- 语法：对象 instanceof 构造函数
			- 如果该对象时构造函数的实例，则返回true，否则返回false
			- Object是所有对象的祖先，所以任何对象和Object做instanceof都会返回true
			
	- 枚举对象中的属性
		for...in
		语法：
			for(var 属性名 in 对象){
			
			}
			
		for...in语句的循环体会执行多次，对象中有几个属性就会执行几次，
			每次讲一个属性名赋值给我们定义的变量，我们可以通过它来获取对象中的属性